# Linux_begin.<br>
#### Дистрибутив GNU/Linux — общее определение операционных систем, использующих ядро Linux, готовых для конечной установки на пользовательское оборудование.<br>
##### Наиболее распространённых дистрибутивы:<br>
- Ubuntu 22.04 "Jammy Jellyfish"
- Debian 10 "Buster"
- Fedora 31
- Linux Mint 19.1 "Tessa"
- Elementary OS 5.0 "Hera"
- Arch Linux
- OpenSUSE 15.1
- Zorin OS 15
- Gentoo Linux 10.1
- OpenMandriva Lx 4.0
- Slackware 15.0

#### Знакомство с командами системой помощи и оболочкой UNIX<br>
- man
- --help
- info

##### man [опции] [раздел] manpage.<br>
Программа предназначена для просмотра страниц руководства (manpages). man присутствует во всех версиях UNIX и является старейшей системой помощи.<br>
Для получения справки о программе, функции, формате файла, в командной строке необходимо набрать man имя_программы.<br>
Документация хранится в специально форматированных текстовых файлах, в директории /usr/share/man.<br>

![Иерархия файловой системы](https://github.com/tvgVita69/Linux_begin/assets/98489171/82618256-a45b-4976-b355-a8e3475b352d)

##### Разделы man.<br>
- man1 Системные утилиты общего пользования
- man2 Функции системы
- man3 Библиотечные функции
- man4 Описание устройств
- man5 Форматы конфигурационных файлов
- man6 Игры
- man7 Различные описания
- man8 Административные утилиты
- man9 Дополнительная документация по ядру

##### Для получения краткой информации о программе, написанной сообществом GNU, следует использовать параметр --help.<br>
Примеры:
- ls --help
- cat --help
  
##### info [menu-item].
Система помощи, разработанная сообществом GNU.<br>
В основном содержит описание программ, созданных GNU сообществом.<br>
Информация хранится в специально отформатированных текстовых файлах.<br>
В отличии от программы ``man``, ``info`` позволяет создавать меню и переходы. Система, чем-то напоминает WEB страницы.<br>

##### Документация к программам.<br>
С программами, входящими в дистрибутивы, поставляется документация.<br>
Документация к программам находится в директории ``/usr/share/doc``. В ней находятся директории с именами программ, в которых, собственно, и расположена документация по конкретной программе.<br>

##### Программы-оболочки.<br>
```
Bourne shell (sh)
Korn shell (ksh)
Bourne again shell (bash)*
C shell (csh)
TC shell (tcsh)
```
    
*В Linux стандартной оболочкой по умолчанию является ``bash``

#### Переменные окружения и встроенные команды bash.<br>
```
SHELL – содержит путь к shell текущего пользователя
LS_COLORS – определяет соответствие между расширениями файлов и теми цветами которыми те отражаются в при выводе командой ls
USER – текущий пользователь
HOME – домашний каталог пользователя USER
PATH – содержит пути для поиска файлов по умолчанию
PWD – указывает на текущий каталог
LANG – определяет текущие настройки локали
```

##### Встроенные команды bash.<br>
```
env – выводит список переменных окружения
export – экспортирует переменные окружения, делая их доступными для других программ
echo – выводит на терминал то, что передано в качестве параметра, в том числе и esc-последовательности*
reset – возврат настроек терминала к значениям по умолчанию
logout – завершение текущего пользовательского сеанса
exit – завершение сеанса работы с оболочкой
```
   
*традиционным способом управления терминалом является отправка на него ``esc-последовательностей``, для чего echo выполняется с ключами ``-ne``

#### Повышение привилегий до суперпользователя.<br>
В Ubuntu по умолчанию отключена возможность входа в систему для суперпользователя.<br> 
Для выполнения команд с правами суперпользователя используется команда ``sudo``.
   
> Пример:   
- sudo su - выполнить команду su, т.е. создать сеанс суперпользователя ``root``
- sudo -i - запустить командную оболочку с правами суперпользователя ``root``. Для выполнения данной команды пользователь должен иметь право на выполнение программы оболочки в среде sudo, например - ``/bin/bash``<br>
##### Другие командыс использованием sudo.<br>
```
$ sudo –l - отобразить список команд, доступных для выполнения текущему пользователю. Кроме списка команд отображаются параметры среды, которые будут применяться при их выполнении.
$ sudo –ll - отобразить список команд, доступных для выполнения текущему пользователю в длинном (расширенном) формате.
$ sudo lshw -C network - отобразить информацию о сетевом оборудовании с правами суперпользователя root
$ sudo –l –U user1 - посмотреть список команд, доступных для выполнения пользователю user1. 
```

##### Командная строка sudo может быть использована в следующих форматах:<br>
```
$ sudo -h | -K | -k | -V
$ sudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]
$ sudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]
$ sudo [-AbEHknPS] [-C num] [-g group] [-h host] [-p prompt] [-u user] [VAR=value] [-i|-s] []
$ sudo -e [-AknS] [-C num] [-g group] [-h host] [-p prompt] [-u user] file
```

#### Управление правами доступа.<br>
Система безопасности ``UNIX`` построена на определении прав доступа к файлам.<br>
```
chmod — изменение прав доступа
umask — маска прав доступа
chown — изменение хозяина
chgrp — изменение группы
```

#### Типы файлов.
Тип файла можно определить по первой букве вывода программы ls -l. <br>
```
f или - — обыкновенный файл
l — символьная ссылка
d — директория
c — символьное устройство
b — блочное устройство
p — pipe (FIFO) файл
s — файл типа socket
```
   
![Система беопастности](https://github.com/tvgVita69/Linux_begin/assets/98489171/c5f699f8-0890-402a-812b-eacd79b4fc39)

##### Типы прав доступа к файлам.<br>
```
r — право на чтение из файла
w — право на запись в файл
x — право на исполнение
```

##### Интерпретация прав доступа к каталогам.<br>
```
r — право на просмотр содержимого директории
w — право на создание, удаление файлов в директории
x — право на «прохождение» в и сквозь директорию
```

##### Числовой формат записи прав.<br>
![Числовой формат записи прав](https://github.com/tvgVita69/Linux_begin/assets/98489171/2745fca1-99ee-4e04-ab2d-286c8f330119)

##### Символьный формат записи прав.<br>
![Символьный формат записи прав](https://github.com/tvgVita69/Linux_begin/assets/98489171/2b58f7c6-ec27-405b-84b8-ede0fa0a26e1)

##### Специальные права.<br>
![Специальные права](https://github.com/tvgVita69/Linux_begin/assets/98489171/a14075af-024f-4b8c-a9da-644a45273e97)

##### Права доступа по умолчанию.<br>
- Для директорий — 777
- Для файлов — 666

#### Основные команды.<br>
![Основные команды работы с файлами](https://github.com/tvgVita69/Linux_begin/assets/98489171/d0f35cbf-9b6b-49c0-ba05-752a2e26e428)

##### Примеры использования команд.<br>
```
ls -alF /etc
pwd
cd /etc
pwd
cd ~
touch test
ls -l test
mkdir -p dir1/dir2/dir3
cp test dir1/dir2
mv test mytest
rmdir dir1/dir2/dir3
cat /etc/passwd
tac /etc/group
more /etc/services
less /etc/rsyslog.conf
ln mytest test
ln -s dir1/dir2/test mytest2
ls -l *test*
rm mytest
rm -rf dir1
ls -l *test*
rm *test*
```

##### Перенаправление ввода-вывода и ошибок.
``cat > testfile`` <br>
Введите строку и нажмите Enter <br>
Нажмите ``Ctrl+D – (EOF)`` для завершения работы<br>
```
cat testfile > testfile 2> errfile
cat errfile
cat /etc/passwd > testfile2
cat < /etc/group > testfile
ls -l /etc > mylist
touch /bin/mycustomfile 2> errfile
cat errfile
```

![Дополнительные команды работы с файлами](https://github.com/tvgVita69/Linux_begin/assets/98489171/c8ae620c-f17b-4771-bb2f-434ba7f7550d)

##### Примеры использования дополнительных команд.<br>
```
 df -h
 du -h /var/log
 ls /etc | sort | less
 ls /etc/*.conf | wc -l
 cat /etc/services | head
 ls -l /etc | tr 'rwx' 'RWX'
 ls -l /etc | tee test | tail
 wc -c test
 dd if=/dev/cdrom of=~/my.iso
 cat | uniq -d
 grep -rsni pppd /usr/share/doc
 cat > test
 line1:the 1st
 line2:the 2nd
 line3:the 3rd
{нажмите Ctrl+D}
 cut -f 1 -d: test > tmp1
 cut -f 2 -d: test > tmp2
 paste tmp2 tmp1 > test
 rm tmp* && cat test
```

#### Файлы Linux.<br> 
Чтобы определить, какая файловаяw система на разделе ``/dev/sda1``, наберите команду ``file`` с ключом ``-s``: <br>
``sudo file -s /dev/sda1``<br>
Чтобы определить какой UUID привязан к какому диску\устройству,  наберите команду ``blkid``<br>
Чтобы получить информацию по дискам и дисковому пространству, выполняем эти команды:<br>
```
df -T - показывает тип файловой системы.
df -Th
df -h отображает информацию о смонтированных разделах с отображением общего, доступного и используемого пространства /dev/sda1 
```

``sd [abcd] [12345] – диск – экземпляр – раздел``

Дисковое пространство принимается за 110%<br>
```
du /var - подсчитывает и выводит размер, занимаемый директорией
du -h -s /var 2>/dev/null
du --max-depth=1 /usr/share/
```

``ls или ls /F   отобразить содержимое указанной директории``<br>
``pwd`` покажет в какой вы директории<br>
``.имяфайла - скрытые файлы``<br>
Какими командами вывести сведения, когда создавался, менялся, был прочитан файл:<br>
``ls -l --time=ctime testfile - когда создавался, менялся``<br>
``ls -l --time=atime testfile - когда был прочитан``<br>
``- регулярные файлы``<br>
``d – директории``<br>
Каталоги.<br>
```
pwd - показать текущую директорию
drwxr-xr-x	 .  – текущий каталог
drwxr-xr-x	 . . – родительский каталог
ls -l ..
```

Переходы между директориями:<br>
```
cd .. перейти в директорию уровнем выше. 
cd ../.. перейти в директорию двумя уровнями выше. 
cd перейти в домашнюю директорию.
cd ~   user перейти в домашнюю директорию пользователя user.
cd -   перейти в директорию, в которой находились до перехода в текущую директорию.
cd /user/user1
cd /../../bin/bash
ls -a ~ 	(~ -    домашний каталог).
id - вывод информации по пользователю uid=0(root) gid=0(root) группы=0(root) контекст=unconfined_u:unconfined_r:unconfined_t:s0
whoami  - вывод информации о пользователе.
mkdir /home/test  - создаст каталог tets.
ls -l - выведет информацию о правах пользователя:
-rw-------. 1 root root 1469 май 21 14:59 anaconda-ks.cfg
-rw-r--r--. 1 root root 1116 май 22 12:49 passwd

rm – удаление файла.
rm -R удаление каталога.
rmdir – удаление пустого каталога.
cp - копирование.
cp /etc/passwd . - копирование в текущую директорию:
[root@cent1 ~]# ls 
anaconda-ks.cfg  passwd
[root@cent1 ~]# 
mv - переименование, перемещение, перемещение под другим именем.
```
##### Создание ссылок в Linux. <br>
ln файл ссылка<br>
ln file1 file2<br>
Символьную ссылку можно создать при помощи команды ``ln`` с ключом ``-s`` (от "symbolic").<br> 
> Например:

```
ln -s /root/lnfile1 /var/softlfile1
Поиск всех жестких ссылок файла (по inode)
touch file1
ln file1 /var/file2
ls -li<br>
5644346 -rw-r--r-- 2 root root    0 Sep 27 21:39 file1   
find / -inum 5644346 2>/dev/null
```
##### Программы поиска файлов:

which – показывает путь к каталогу указанного файла<br>
which nano<br>
locate -  позв. найти файл, указанный по имени<br>
locate hello<br>
cat (concatenation, firstly, In pair with split command)<br>
сегодня используется для вывода на экран содержимого файла<br>
tac file1 -вывести содержимое файла file1 на стандартное устройство вывода в обратном порядке (последняя строка становиться первой и т.д.)<br>

##### Пример создания и заполнения файла командой cat:<br>
```
~# cat > file1
12345
^C
~# cat >> file1
23456
^C
~# cat file1
~# tac file1
```

split разбивала файл на дискеты по 1440, cat потом собирала файл:

> Пример:

 ```
dd if=/dev/zero of=bigfile1 bs=1024 count=20000
$ split -a 1 -d -b 2M bigfile1 bigfile1.part<br>
rm bigfile1
$ cat bigfile1.part* > bigfile1.iso<br>
rm  bigfile1.part*
```

more  - скроллинг только вниз<br>
more /etc/passwd<br>
less - скроллинг вверх и вниз, PgUp / PgDwn работает<br>
> Например, man форматирует для вывода на устройство, а less выводит<br>
Выход из команды: q<br>
Для просмотра логов - tail. По умоnчанию, выводит 10 последних строк. Можно переопределить параметром –n.<br>
```
tail -n 20 /var/log/auth.log
tail -f -n 0 /var/log/auth.log
```

выводим на экран 0 старых записей ``(-n 0)`` и ждем появления для отображения новых ``(-f)``.<br>
Для разделения результатов вывода м. исп. ``================= "Enter"``<br>
Для выхода исп. ``Ctrl + C`` сигнал «завершить работу»<br>
Противоположно предыдущей команде, ``head`` выводит начало файла.<br>
Работа с историей команд ``history``<br>
Ctrl + r – шаблон поиска – поиск по истории<br>
Для просмотра списка ранее введенных команд в ``bash`` — имеется команда ``history``. 
По умолчанию все пишиться в файл ``~/.bash_history``, а его размер — 500 команд.<br>
Если хотим хранить историю в другом файле, то нужно в ``.bashrc``, задать команду ``HISTFILE=~/.my_history``.<br>
``HISTSIZE`` — определяет число строк, хранящихся в списке истории (в памяти интерпретатора).<br>
``HISTFILESIZE`` — максимальное количество команд хранящихся в файле <br>
``$ export HISTSIZE=1000``<br>
``$ export HISTFILESIZE=1000``<br>
возможность указать количество выводимых строк (команд):<br>
``$ history 20<br>``
все команды имеют номер, с помощью которого к ней можно обратится.<br>
Если нам надо повторить 28 команду, то просто набираем в терминале:
``$ !28``<br>
Cписок наиболее распространенных команд:<br>
```
!!   ссылается на предыдущую команду
!n   ссылается на команду под номером n 
!-n  ссылается на команду по номером текущая минус n 
history -c      очистить историю команд, удалив все записи 
history -dn    удалить из истории запись под номером n 
history -a      дописать команды, введенные в текущей сессии bash, в конец файла $HISTFILE 
```
Так же можно сохранить дату и время для каждой команды в истории, для этого в конец ``.bashrc`` дописываем:<br>
``nano .bashrc``<br>
Для начала найдём где есть файл .bashrc<br>
```
find / -name .bashrc
/root/.bashrc
/home/user/.bashrc
```

Дописываем строку в конец файла  .bashrc дописываем<br>
``export HISTTIMEFORMAT=" %h/%d-%H:%M:%S  "``<br>
Перезагружаем скрипт .bashrc<br>
``. ~/.bashrc``
Или<br>
``source ~/.bashrc``

#### Регулярные выражения. Редакторы.<br>
#####Регулярные выражения<br>
##### man re_format
Общая схема регулярного выражения<br>
регулярное выражение состоит из трёх основных частей:<br>
```
1. Якорь – определяет позицию шаблона в строке текста:
^ – якорь, определяющий начало строки;
$ – якорь, определяющий конец строки.
2. Шаблон - набор (последовательность) символов – для поиска соответствий в заданных позициях строки текста: 
символ "точка" (.) соответствует любому произвольному символу;
алфавитно-цифровые символы и пробел представляют сами себя;
прочие символы – интерпретация зависит от диалекта.
3. Модификатор – задаёт количество повторов предыдущего символа или набора символов (в зависимости от диалекта): 
* любое количество повторов символа/набора, в том числе и нулевое;
? соответствует нулю или одному экземпляру символа/набора;
```

#####Символы базовых регулярных выражений:<br>
```
^ соответствует началу строки;
Пример: grep '^s' /etc/passwd
 $ соответствует концу строки;
Пример: grep 'sh$' /etc/passwd
 [] любой символ из числа заключенных в скобки (символы могут быть разделены запятыми, указание диапазона - [0-9]); 
Пример: [012345789] – соответствует одному цифровому символу из заданного набора;
Предназначены для задания подмножества символов. Квадратные скобки, внутри регулярного выражения, считаются одним символом, который может принимать значения, перечисленные внутри этих скобок. Метасимвол ^ означает отрицание множества:
 [^] любой символ кроме тех что указаны в скобках;
Пример: grep '^[rs]' /etc/passwd
 \ Служит для экранирования специальных символов, т.е. отменяет спец. значение следующего за ним метасимвола;
Пример: grep 'bin\/sh' /etc/passwd<br>
-- \<...\> --  Экранированные "угловые скобки" - задают границы слова (не работает в sed).
Пример: grep -R '\<sed\>' /usr/share
. Означает не менее одного любого символа;
* Означает любое количество символа в строке, предшествующего «звездочке», в том числе и нулевое число символов;
Например, имеется шаблон для поиска любого количества символов, заключённых в кавычки:
".*"
-- \( \) --Экранированные "круглые скобки" 
Предназначены для выделения групп регулярных выражений. Они полезны при использовании с оператором «\|» и при извлечении подстроки. 
-- \{ \} -- Экранированные "фигурные скобки"
Задают число вхождений предыдущего выражения. Для уточнения количества повторений наборов символов применяется модификатор \{min,max\}.
Пример: grep '\(ro.*\)\{2\}' /etc/passwd<br>
Пример: ip a | grep '[1-9][0-9]\{0,2\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}'
Зная, что в каждой части IP-адреса может содержаться от одной до трёх цифр, запишем модификатор в виде \{1,3\}. Символы "обратный слэш" перед точками необходимы для того, чтобы отменить их специальный статус универсального метасимвола.
 \{n\} указывает на то что предыдущий шаблон встречается ровно n раз;
 \{n,\} указывает на то что предыдущий шаблон встречается не менее n раз;
 \{,m\} указывает на то что предыдущий шаблон встречается не более m раз;
 \{n,m\} указывает на то что предыдущий шаблон встречается не менее n раз и не более m раз;
n|m выбор из двух шаблонов
 \> признак конца слова;
```

#####Классы символов:<br>
```
 [:upper:] -[A-Z];
 [:lower:] -[a-z];
 [:digit:] -[0-9];
 [:alnum:] -[0-9a-zA-Z];
 [:space:] -символ пробела;
 [:alpha:] -[A-Za-z];
```

> Пример: ``# grep [[:upper:]] /etc/passwd``<br>
```
*grep [параметры] регулярное_выражение [файл]
-c -задает отображение только числового значения, сколько строк соответствует шаблону;
-i -игнорировать регистр;
-h -подавляет вывод имен файлов, включающих найденные строки;
-l -только отображение имен файлов, содержащих найденные строки;
-n -нумерация выводимых строк;
-s -подавляет вывод сообщений о несуществующих или нетекстовых файлах и ошибках;
-v -отображение строк, не соответствующих шаблону;
-E -включение расширенных регулярных выражений;
```

##### POSIX делит регулярные выражения на две категории: 

``BRE (Basic Regular Expressions)`` и ``ERE (Extended Regular Expressions)``. <br>
В обеих категориях поддерживаются метасимволы ``. и *``, якоря `` ^ и $``, группирование символов в скобках (для BRE скобки экранируются обратным слэшем), применение квантификаторов ``\{min,max\}`` к группам в скобках.<br> 
Запоминание и повторное использование ``\1...\9`` поддерживает только категория ``BRE``, а квантификаторы ``+ и ?`` и конструкцию выбора – только категория ``ERE``.<br>
Символы расширенных регулярных выражений.<br>
Многие символы, экранируемые в базовых выражениях– ``() {} | –но не– <>`` используются без экранирования. <br>
Знак вопроса ``-- ? --`` <br>
Означает, что предыдущий символ или регулярное выражение встречается 0 или 1 раз. <br>
``$ grep -E '^r?o' /etc/passwd`` <br>
Знак "плюс" -- + --<br>
Указывает на то, что предыдущий символ или выражение встречается 1 или более раз. 

#####Как вывести из конфига только незакомментированные строки? Использовать рег выражение:<br>
```
grep '^#' /etc/ssh/sshd_config (спец символы засовываем в  ‘’)
grep '^#' /etc/ssh/sshd_config (^# начинаются с #)
grep -v '^#' /etc/ssh/sshd_config (-v начинаются не с #)
grep -v '^#\|^$' /etc/ssh/sshd_config (при отрицании -v  «и» (оператор «\|» )меняется на «или» , т.е. не содержат пробелы ^$)
Вывести общее кол-во папок в указанной директории: ls -l ~ | grep "^d" | wc -l
```
----------------------------------------------------------------
##### Потоковые редакторы.<br>
Потоковый редактор ``sed``<br>
Формат команды ``sed команды_редактирования [имя_файла]`` <br>
```
-i – редактировать файл
sed -i 's/string1/string2/' example.txt 	в файле example.txt заменить "string1" на "string2", результат вывести на стандартное устройство вывода. 
sed -i '/^$/d' example.txt 	удалить пустые строки из файла example.txt
sed  -i '/ *#/d; /^$/d' example.txt 	удалить пустые строки и комментарии из файла example.txt 
-e – добавить к команде скрипт
sed -e '1d' example.txt	удалить первую строку из файла example.txt<br> 
sed -n '/string1/p' example.txt	отобразить только строки содержащие "string1" 
sed -e 's/ *$//' example.txt 	удалить пустые символы в конце каждой строки
sed -e 's/string1//g' example.txt 	удалить строку "string1" из текста, не изменяя всего остального 
sed -n '1,8p;5q' /etc/passwd	взять из файла с первой по восьмую строки и из них вывести первые пять 
sed -n '5p;5q' /etc/passwd	вывести пятую строку
sed -e 's/0*/0/g' /etc/passwd	заменить последовательность из любого количества нулей одним нулём
```
____________________________________________________________________________

##### Еще пример:<br>
```
g > output.txt
sed -e 's/\(.*\)/\U\1/' sshd_config > output.txt  --- запись содержимого файла с большой буквы
sed -e 's/\(.*\)/\L\1/' sshd_config > output.txt   -- запись содержимого файла с маленькой буквы
```

##### Утилита TR.<br>
Команда tr служит для перевода выбранных символов в другие символы или удаления их, ``tr`` не принимает имен файлов в качестве аргумента.<br>
``echo 'test' | tr '[:lower:]'  '[:upper:]' ``	преобразовать символы из нижнего регистра в верхний<br>
``cat sshd_config | tr '[:lower:]'  '[:upper:]' ``
*P.s. Пробел должен быть между lower и upper. И привязана строка к регистрам.<br>

##### Редактор VI.<br>
```
Vi –есть везде.<br>
vimtutor –встроенный учебник<br>
Cp /etc/passwd ~<br>
Cd<br>
Vi passwd<br>
J -вниз<br>
K –вверх<br>
L –вправо<br>
G –в начало на первый символ<br>
Редактирование текста<br>
Режим вставки <br>
i	-ввод текста с текущей позиции<br>
o	-ввод текста с новой строки<br>
Командный режим<br>
J	-склеить строки<br>
x	-удалить текст (DEL)<br>
X	-удалить текст (BACKSPACE)<br>
yy	-копировать строку в буфер<br>
dd	-вырезать строку в буфер<br>
p	-вставить строку из буфера под выбранной строкой<br>
P -вставить строку из буфера над выбранной строкой<br>
u	-отменить последнее действие<br>
```
<br>Командный режим – во всем тексте замени значение `` Х на 1:%s/X/1/g``
<br>Редактирование конфигов<br>
Перед редактированием конфига, его оригинал нужно сохранять<br>
Кроме ``cp /etc/ssh/sshd_config /etc/ssh/sshd_configXXXXXX``<br>
Можно и лучше использовать систему контроля версий (только ее нужно сначала установить<br> 
``apt-get install rcs``<br>
``RCS`` это Система Управления Исправлениями ``revision control system``<br>
``RCS`` включает в себя следующие программы:<br>
```
rcs, которая управляет атрибутами архивного файла RCS;<br> 
ci и co, проверяющие старые и измененные архивы RCS;<br>
ident, которая производит поиск в архивах RCS по ключевому слову;<br> 
rcsclean, программа которая удаляет нерабочие или неизмененные файлы; <br>
rcsdiff, которая запускает diff для сравнения версий;<br> 
rcsmerge, которая объединяет результаты работы двух пользователей над файлом в один работающий файл;<br> 
rlog, которая выводит сообщения из журнала RCS.<br>
```

Создать каталог для репозитория ``mkdir RCS``<br>
Затем импортировать файл:<br>
``ci testfile``<br>
Исходный файл _перемещается_ в репозиторий (если он там уже есть, то под новой версией).<br>
``[ci -l  /etc/ssh/sshd_config – запомнить состояние файла.]``<br>
Предложит ввести комментарий, если идей нет просто ставим ``". "``<br>
Извлечь файл из репозитория можно командой:<br>
``co testfile`` (файл будет иметь права доступа 444)<br>
Чтобы изменить файл, нужно установить его блокировку и установить права доступа, разрешающие запись<br>
```
rcs -l testfile<br>
chmod o+w testfile<br>
cat >> testfile<br>
23232323<br>
```

Правим файл, смотрим рез:<br>
``rcsdiff testfile`` смотрим, что (на что) поменялось.<br>
Строка -измененная строка (1a2)<br>
``1a2`` первой добавилась вторая<br>
``> 23232323`` что добавилось (операция)<br>
Чтобы записать изменения нужно снова выполнить<br>
``ci testfile``<br>
``rlog ./testfile`` сколько и какие версии и ревизии версий
что поменялось относительно указанной версии:<br>
``co testfile``<br>
``rcsdiff  -r1.1 testfile``<br>
что поменялось между указанными версиями:<br>
``rcsdiff  -r1.1  -r1.2  testfile``

#### Процессы.<br>
Управление сервисами и процессами:<br>
##### Ps.
``ps aux`` -отобразить все существующие процессы.<br>
``ps a``  -все интерактивные процессы.<br>
``ps ax`` -все процессы.<br>

##### pstree –выводит дерево процессов.<br>
Каждый запущенный процесс в любой момент времени находится в одном из следующих состояний (статусов):<br>
- Активен (R=Running) –процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного кванта времени центрального процессора.
- «Спит» (S=Sleeping) –процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса.
- Находится в состоянии непрерываемого ожидания (D=Direct) –процесс ожидает определенного («прямого») сигнала от аппаратной части и не реагирует на другие сигналы;
- Приостановлен (T) –процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ).
- «Зомби» (Z=Zombie) –это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены.
   
##### Потоки данных<br>
У каждой программы существует 3 системных потока: ``stdout, stderr, stdin``<br>
Linux предоставляет специальные команды для перенаправления каждого потока<br>
Команды с одной угловой скобкой переписывают существующий контент целевого файла:<br>
```
> —стандартный вывод
< —стандартный ввод
2> —стандартная ошибка
```

##### Команды с двойными угловыми скобками не переписывают содержимое целевого файла:<br>
```
>> —стандартный вывод
<< —стандартный ввод
2>> —стандартная ошибка
```

Можно создать каналы ``(pipes)``. между двумя процессами, в который один процесс сможет писать поток байтов, а другой процесс сможет его читать.<br> 
При помощи каналов организуются конвейеры оболочки. Когда оболочка видит строку вроде<br>
``команда1 | команда2``<br>
##### Переменные окружения.<br>
> Пример:<br> 
```
date<br>
unset LANG ##отменить унаследованную переменную<br>
date<br>
export LANG=ru_RU.UTF-8 ##вернуть значение взад. Экспортировать потомкам<br>
date
```<br>
##### СИГНАЛЫ.
Позволяют управлять программным обеспечением отличие сигналов от других средств взаимодействия между процессами заключается в том,<br>
что их обработка программой обычно происходит сразу же после поступления сигнала (или не происходит вообще), независимо от того, что программа делает в данный момент.<br>
Сигнал прерывает нормальный порядок выполнения инструкций в программе и передает управление специальной функции – обработчику сигнала.<br>
``SIGHUP (номер 1)`` изначально был предназначен для того, чтобы информировать программу о потере связи с управляющим терминалом (терминалы часто подключались к системе с помощью модемов, <br>
так что название сигнала происходит от hung up – повесить трубку). В ответ на получение ``SIGHUP`` демон обычно перезапускается (или просто повторно читает файл конфигурации).<br>
> Например, поменяли порт в ``/etc/ssh/sshd_conf- (sed -i 's/22/222/' /etc/ssh/sshd_config)`` сделали<br>
ps aux | grep user1<br>
kill -s HUP <PID><br>
или<br>
kill -HUP <PID><br>
оно же<br>
kill -1 <PID><br>
и не надо перезагрузки сервиса.<br>

``SIGINT`` (номер 2) обычно посылается процессу, если пользователь терминала дал команду прервать процесс (обычно эта команда – сочетание клавиш ``Ctrl-C``) .<br>
``SIGKILL`` (номер 9) завершает работу программы. Программа не может ни обработать, ни игнорировать этот сигнал.<br>
``SIGCONT`` (номер 18) возобновляет выполнение процесса, остановленного сигналом ``SIGSTOP``<br>
``SIGSTOP`` (номер 19) приостанавливает выполнение процесса. Как и SIGKILL, этот сигнал не возможно перехватить или игнорировать.<br>
> Пример: работает юзер через терминал. Смотрим сеансы ``pts (ps ax | grep userX)`` <br>
[netstat –apnt | grep ssh | grep ‘*’]<br>
``Kill –STOP <PID>``   	остановка процесса<br>
``Kill –CONT <PID>``	  продолжить выполнение остановленного процесса<br>
``Kill –KILL <PID>``

``Guided – use entire disk``<br>
После первого запуска настройка ip адреса.<br>
> Пример:<br>
```
sudo ifconfig eth0 inet 172.16.1.X/24
sudo route add default gw 172.16.1.254
Или<br>
sudo ifconfig enp0s3 inet 172.16.1.X/24
sudo route add default gw 172.16.1.254
```
------
Настройка адреса через конфиг:<br>
```
 vi /etc/network/interfaces
 auto eth0
 iface eth0 inet static
 address 172.16.1.X
 netmask 255.255.255.0
 gateway 172.16.1.254
 dns-nameservers 172.16.1.254
 dns-search corpX.un
```

Старый способ именования интерфейсов задается в ``/etc/default/grub``<br>
```
GRUB_CMDLINE_LINUX=""
to
GRUB_CMDLINE_LINUX="net.ifnames=0"
Then, type in:
sudo update-grub
and reboot your system
sudo reboot   
```
-----
Настройка файлов конфигурации.<br>
``sudo nano /etc/hostname и /etc/hosts`` <br>
Указать имя компьютра, например для машины server:<br>
```
Server
Sysctl – управление ядра
Systemctl – управление системой инициализации
```   





